<!--
%\VignetteEngine{knitr}
%\VignetteIndexEntry{Mchof Vignette}
-->

```{r css}
options(markdown.HTML.stylesheet = 
    	system.file("misc", "vignette.css", package = "mchof"))
```

Mchof Vignette
=================================

## 1 Introduction



## 2 Installation

If you are reading this vignette you have probably installed mchof; if not just run

```
install.packages("mchof")
```

It is also possible to install the development version of mchof by using `install_github("mchof", "rgrannell1")`, though this is not recommended; the development version is usually unstable, and often doesn't build. Updates will be released frequently, with an release date being given in the README.

To load the package, use

```{r}
require(mchof)
```

## 3 Example Programs

Below are a few simple programs showing typical uses of mchof. These algorithms are chosen because they are illustrative, not because they are particulaly good algorithms.

### 3.1 Enumerating the Prime Numbers

Many programs involve finding correct solutions from a set of candidate solutions; for example enumerating prime numbers, finding the solution to a linear equation, or finding cycle-free paths in a graph. These tasks can be easily expressed in terms of `mcSelect`, `mcReject`, or `mcPartition`.

A simple algorithm for finding all the primes in the set 1, 2,..., n is to use the sieve of Eratosthenes, which excludes values that are are divisible by any number smaller than that value (excluding one).

First, we need to create a function that return TRUE is a number n is prime, otherwise returning FALSE.

```{r}
is_prime <- function (n) {
	if (n == 1) FALSE else {
		all( as.logical(n %% 2:(n-1)) )
	}
}
```

Now we can select the elements of the set 1...20 that return true for `is_prime`, returning a new set composed only of prime numbers.

```{r}
mcSelect(is_prime, 1:20)
```

Similarily, mcPartition divides the set 1...20 into a two sets; the prime numbers and the 
composite numbers. Although this function is essentially mcSelect paired with mcReject,
it is useful in its own right for recursively partitioning a list in a tree-like manner.

```{r}
mcPartition(is_prime, 1:20)

```
mcReject returns only the composite numbers

```{r}
mcReject(is_prime, 1:20)

```

### 3.2 Solving Linear Equations

A slightly tougher problem is finding the smallest coefficients that solve a polynomial equation
for a given value of x (by smallest, I mean the set of coefficients a, b, c that have the smallest summed absolute value).

```{r}
is_solved <- function (a, b, c, x) {
	# is the quadratic equation solved?
	(a * x^2 + b * x + c) == 0
}
smallest_quadratic <- function (x, range = c(rev(-seq_len(20)), seq_len(20))) {
	# get the cartesian product of the set
	
	tmp <- expand.grid(range, range, range)

	# get the columns in tmp, zip them into tuples, and
	# unlist tuples into vectors
	product_set <- mcUnzipWith(
		function (x) unlist(x),
		list(tmp[,1], tmp[,2], tmp[,3]))
	
	mcReduce(
		function (smallest, new) {
		# pick the set of coefficients with the
		# minimum summed absolute values
		if ( sum(abs(new)) < sum(abs(smallest)) ) new else smallest
		},
		mcSelect(
			function (coef) is_solved(coef[1], coef[2], coef[3], x),
			product_set))
}
smallest_quadratic(5)
```

There are three main steps in this program:

First, the set product of range (the candidate values of the coefficient) is computed.
The data is stored as a data frame, in which column one represents values of 
a, column two represents values of b, and column three represents values
of c. Each row in the dataframe gives a combination a, b, c. 

mcUnzipWith takes the three columns a, b and c, returns a list of rows, and then converts each row to a vector by applying unlist to them.

Second, mcSelect (identical to mcFilter) selects the coefficients that solve the quadratic equation for a given value of x.

Third, mcReduce assumes the first set of coefficients are the smallest in the list. If 
the second set of coefficients is smaller then these are assumed to be the smallest,
and so on for the rest of the list. This ultimately returns the smallest set of coefficients that solve the equation.

This program shows some of the main uses of mchof; using the zip family of functions to 
reshape data from a "column" format to a "list of rows" format before applying some function
to them, the filter family of functions to return a subset of a list matching some function, and mcReduce to greedily find a value in a list.

## 4 Appendices

### 4.1 Parallel Options

Mchof currently uses mclapply from the parallel library for its parallel backend. `mclapply( )` works with very little effort on the part of the user, but unfortunately it doesn't work on windows (since windows does not allow forking). 

It is likely that this will change in upcoming versions in order to add support for windows; as of now the most important option is mc.cores, which sets the number of processes to spawn. 

For further details see `mclapply( )` in the parallel library for a more complete description of the options that can be used with mchof. 

Note that for obvious reasons FUN or X cannot be set in paropts in case they conflict with f and x (arguments available to most mchof functions).

### 4.2 Multiple Argument Functions

Most functions used with higher-order functions take a fixed number of arguments.This can be a problem when you want to set optional parameters for the input function.

Take for example, if you want to concatenate the elements of a vector with commas seperating each element you could use;

```{r}
comma_paste <- function (vector) {
	paste0(vector, collapse = ", ")
}
Map(
	comma_paste, 
	list(
		c("a", "b", "c"),
		c("1", "2", "3"),
		c("do", "ray", "me")
	))
```

Before handing the multi-parameter paste0 function to `Map( )` it is transformed
into a one-parameter function `comma_paste( )`. This type of transformation is 
known as *currying*. Generally it is more convenient to do this kind of transformation
using an anonymous function.

```{r}
pasted_vectors <- Map(
	comma_paste, 
	list(
		c("a", "b", "c"),
		c("1", "2", "3"),
		c("do", "ray", "me")
))

mcSelect(
	function (vector) {
		paste0(vector, collapse = ", ") == "a, b, c"	
	},
	list(
		c("a", "b", "c"),
		c("1", "2", "3"),
		c("do", "ray", "me"))
)
```

### 4.3 NA Handling

This package is composed of many small, composable functions as opposed to larger 
functions with many optional parameters. As a result of this it is sometimes necessary to transform your arguments slightly before using them as inputs. NA handling may be one of these cases.

Several functions (including mcSelect, mcReject) take a function that returns
TRUE or FALSE. R uses three-value logic (TRUE, FALSE, NA), so NA must be converted
either TRUE or FALSE internally. Users can control which value
NA is converted to by *composing* their original function with one of these 
three functions;

```{r}
na_as_true <- function (f) {
	function (...) {
		logical <- as.logical(f(...))
		is.na(logical) || logical
	}
}
```

```{r}
na_as_false <- function (f) {
	function (...) {
		logical <- as.logical(f(...))
		isTRUE(logical)
	}
}
```

```{r}
na_as_error <- function (f) {
	function (...) {
		logical <- as.logical(f(...))
		if (is.na(logical)) {
			stop("NA produced", call. = FALSE)
		}
	}
}
```

Each of these functions returns a new, modified function with the appropriate
error handling behaviour.

For example, mcFilter assumes that NA means FALSE. If we were trying to get every
value divisible by two but we also wanted to keep values that produced NA, we 
could use the following

```{r}
mcFilter(
	na_as_true( function (x) x %% 2 ),
	c(1:10, NA)
)
```

### 4.4 Strings as Function Names

Functions like mcFold and mcReduce take binary functions such as plus or multiply.
It would be frustrating to have to write `get('+')` every time you wanted to call
an infix operator, so all mchof functions also accept a function name
in place of an actual function. For example, if you wanted to sum the vector 
1..10 you might write something like; 

```{r}
mcReduce('+', seq_len(10))
```

or

```{r}
mcFold('+', 0, seq_len(10), list(mc.cores = 2))
```

